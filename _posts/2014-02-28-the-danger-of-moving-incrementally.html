---
layout: post
title: The Danger of Moving Incrementally Updated Datafile Copies
date: '2014-02-28T11:20:00.000-06:00'
author: Don Seiler
tags:
- dba
- backup
- nfs
- 11gR2
- rman
- oracle
modified_time: '2014-02-28T11:20:04.422-06:00'
blogger_id: tag:blogger.com,1999:blog-7032512792942232766.post-678057506044851513
blogger_orig_url: http://www.seiler.us/2014/02/the-danger-of-moving-incrementally.html
---

When I sat down at my desk yesterday morning I was greeted with some disturbing email alerts notifying me that one of the NFS mounts on my standby database host was full. This was the NFS mount that held an image copy of my database that is updated daily from an incremental backup. The concept and an example can be <a class="vt-p" href="http://docs.oracle.com/cd/E11882_01/backup.112/e10642/rcmbckba.htm#BRADV8186" target="_blank">found in the documentation</a>. With a 25Tb database, waiting to restore from backups is not as appealing as simply switching to the copies and getting back to business.<br /><br />We quickly saw that the reason that this mount was full was that RMAN had tried to make another set of image copies in the latest backup run rather than take an incremental backup for recovery. It does this when it finds no valid copy of the datafiles to increment, and the logs confirmed this to be the reason:<br /><br /><span style="font-family: Courier New, Courier, monospace;">Starting backup at 2014/02/26 13:30:16</span><br /><span style="font-family: Courier New, Courier, monospace;">no parent backup or copy of datafile 792 found</span><br /><span style="font-family: Courier New, Courier, monospace;">no parent backup or copy of datafile 513 found</span><br /><span style="font-family: Courier New, Courier, monospace;">no parent backup or copy of datafile 490 found</span><br /><span style="font-family: Courier New, Courier, monospace;">no parent backup or copy of datafile 399 found</span><br /><div><br /></div><div>... and so on, for every datafile. However I knew that the copies that had been there (and been updated) every day were still there. So what was different?</div><div><a name='more'></a><br /></div><div>It was then that I remembered my work from the day before. Doing a bit of re-organization, I renamed the directory where the datafile copies lived. However I made sure to re-catalog them and double-checked to make sure the backup tag was still there, which it was. I also crosschecked the copies to make the old entries as expired and then deleted them from the catalog. This turned out to be the cause of the problem.</div><div><br /></div><div>When the original datafilecopy entries were removed from the catalog, RMAN didn't want to recognize the new entries as the right copies, even though they were <i>literally </i>the same file, <b>with the same backup tag</b>. And so RMAN printed the message you see above and dutifully began making new image copies until it filled up the mountpoint, which didn't have another spare 25 Tb handy.</div><div><br /></div><div>Today I was able to duplicate the scenario on a (much smaller) sandbox with various sequences. Every time, once I crosschecked the original copies and deleted them as expired, RMAN would create a new copy on the next run. The sequence was basically this:</div><div><ol><li>Run backup-for-recovery and recover commands. First time will create datafile copies as expected.</li><li>Run it again, this time it will create an incremental backup and then apply it to the copies made in the previous step.</li><li>Move or rename the directory holding the copies.</li><li><span style="font-family: Courier New, Courier, monospace;">CROSSCHECK COPY;</span> &amp; <span style="font-family: Courier New, Courier, monospace;">DELETE EXPIRED COPY;</span></li><li><span style="font-family: Courier New, Courier, monospace;">CATALOG START WITH '/path/to/new/location/';</span></li><li><span style="font-family: Courier New, Courier, monospace;">LIST DATAFILECOPY ALL;</span> to verify that the copies are registered under the new location and the TAG is right.</li><li>Run backup-for-recovery and recover commands (be sure to update the location). I would expect the same results as step 2, but instead new copies are created.</li></ol></div><div>One thing that was very interesting was that if I just cataloged the new location, but did not crosscheck or delete the old entries (i.e. skipped step 4), then I could run the script and it would take an incremental backup as planned and recover the copies in the new location. But then if I later did the crosscheck and delete, it would not accept those copies and create new copies. And all this time I can "list datafilecopy all;" and see both copies with the same tags. Changing the order of steps 4 and 5 made no difference.</div><div><br /></div><div>I'd be interesting to know what anyone else thinks about it. Personally it seems like a bug to me, so I've opened an SR. So far Oracle Support have confirmed what I've experienced, although have said there is no bug on file. They suggested I use Doc ID 1578701.1 to make another copy of the datafile with a new tag and use that new tag. However if I wanted to do that I would just create a new database copy and keep using the original tag, which is exactly what I've done.<br /><br />I will be sure to update this post with anything I find. Until then, I wanted to share this experience for anyone else that might need or want to move their datafile copies if they are part of an incrementally-updated-backup strategy.</div>