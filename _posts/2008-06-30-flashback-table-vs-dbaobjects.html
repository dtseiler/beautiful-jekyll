---
layout: post
title: FLASHBACK TABLE vs. DBA_OBJECTS.LAST_DDL_TIME
date: '2008-06-30T13:07:00.001-05:00'
author: Don Seiler
tags: 
modified_time: '2010-11-20T11:47:09.644-06:00'
blogger_id: tag:blogger.com,1999:blog-7032512792942232766.post-739444366595950112
blogger_orig_url: http://www.seiler.us/2008/06/flashback-table-vs-dbaobjects.html
---

<em><span class="Apple-style-span" style="font-size: x-small;">NOTE: This post originally appeared on The Pythian Group blog on 6 June 2008, and is reposted here with permission.</span></em><br /><br />A little over a week ago, a <a href="http://www.pythian.com/blogs/author/billette">teammate</a> and I were trying to use Oracle’s <a href="http://download.oracle.com/docs/cd/B19306_01/server.102/b14220/backrec.htm#sthref2386">FLASHBACK TABLE</a> to undo an “oops” <code>UPDATE</code> statement that a client’s developers had run on one of their test databases, clearing data from two columns in all rows of the table. The statement was actually part of a script that also contained <code>ALTER TABLE</code> statements to add columns.  This is important to note because <code>FLASHBACK TABLE</code> will only let you go back as far as the most recent DDL against that table.  To quote <a href="http://download.oracle.com/docs/cd/B19306_01/server.102/b14200/statements_9012.htm#SQLRF01802">the SQL reference</a>, “Oracle Database cannot restore a table to an earlier state across any DDL operations that change the structure of the table.”<br /><br /><a name='more'></a>This led me to another question: Is there a way to directly see to precisely what date and time you can flashback a table? The developer couldn’t give me a precise time, only that the <code>UPDATE</code> statement was executed immediately after the structure-changing DDL, making my target window very small. Naturally, one would think that the <code>LAST_DDL_TIME</code> in the <code>DBA_OBJECTS</code> view would hit that nail on the head. However it turns out that the key bit of that SQL reference quote is “change the structure of the table.”<br /><br />It turns out that there are a few statements that will update the <code>LAST_DDL_TIME</code> without changing the table structure.  For example, <code>GRANT</code> and <code>REVOKE</code> statements, which provide a user with certain privileges on an object, will trigger an update to <code>LAST_DDL_TIME</code>.  You can then go ahead and flashback the table prior to the privilege change.  Another item to note is that a prerequisite to <code>FLASHBACK TABLE</code> is to enable row movement on that table, via (you guessed it) an <code>ALTER TABLE</code> statement.  The <code>ALTER TABLE foo ENABLE ROW MOVEMENT</code> statement also bumps <code>LAST_DDL_TIME</code>, but obviously doesn’t block <code>FLASHBACK TABLE</code> from going past it in time.<br /><br />The bottom of all this is that you can’t use <code>LAST_DDL_TIME</code> to determine just how far back you can go with a <code>FLASHBACK TABLE</code> statement, as you can most likely go past it due to various non-structure-changing DDL statements that affect that timestamp.<br /><br />Here’s a little demonstration to illustrate this point:<br /><pre><span style="color: green;">-- Get our preferred date format<br />SQL&gt; alter session set nls_date_format='YYYY/MM/DD HH24:MI:SS';<br /><br />Session altered.<br /><br />SQL&gt;<br />SQL&gt; -- First we need something to play with<br />SQL&gt; create table emp<br />  2  as select * from hr.employees;<br /><br />Table created.<br /><br />SQL&gt;<br />SQL&gt; -- alter row movement to allow for flashback<br />SQL&gt; -- NOTE: this also updates last_ddl_time<br />SQL&gt; alter table emp enable row movement;<br /><br />Table altered.<br /><br />SQL&gt;<br />SQL&gt; -- Note the last_ddl_time given in the<br />SQL&gt; -- dba_objects view<br />SQL&gt; select last_ddl_time<br />  2  from dba_objects<br />  3  where owner=user and object_name='EMP';<br /><br />LAST_DDL_TIME<br />-------------------<br />2008/05/28 22:09:11                                                             <br /><br />SQL&gt;<br />SQL&gt; -- Let some time elapse, get a drink of water<br />SQL&gt; exec dbms_lock.sleep(120);<br /><br />PL/SQL procedure successfully completed.<br /><br />SQL&gt;<br />SQL&gt; -- Get a marker, note this.<br />SQL&gt; select sysdate from dual;<br /><br />SYSDATE<br />-------------------<br />2008/05/28 22:11:11                                                             <br /><br />SQL&gt;<br />SQL&gt; -- Note the salary before the DML<br />SQL&gt; select first_name, last_name, salary<br />  2  from emp<br />  3  where employee_id=101;<br /><br />FIRST_NAME           LAST_NAME                     SALARY<br />-------------------- ------------------------- ----------<br />Neena                Kochhar                        17000                       <br /><br />SQL&gt;<br />SQL&gt; -- Let's give her a 15% raise<br />SQL&gt; update emp<br />  2  set salary = salary * 1.15<br />  3  where employee_id=101;<br /><br />1 row updated.<br /><br />SQL&gt;<br />SQL&gt; -- Don't forget the commit!<br />SQL&gt; commit;<br /><br />Commit complete.<br /><br />SQL&gt;<br />SQL&gt; -- Observe the new salary<br />SQL&gt; select first_name, last_name, salary<br />  2  from emp<br />  3  where employee_id=101;<br /><br />FIRST_NAME           LAST_NAME                     SALARY<br />-------------------- ------------------------- ----------<br />Neena                Kochhar                        19550                       <br /><br />SQL&gt;<br />SQL&gt; -- Get another marker<br />SQL&gt; select sysdate from dual;<br /><br />SYSDATE<br />-------------------<br />2008/05/28 22:11:11                                                             <br /><br />SQL&gt;<br />SQL&gt; -- Now let's run bump last_ddl_time with a grant<br />SQL&gt; grant select on emp to hr;<br /><br />Grant succeeded.<br /><br />SQL&gt;<br />SQL&gt; -- Check it out<br />SQL&gt; select last_ddl_time<br />  2  from dba_objects<br />  3  where owner=user and object_name='EMP';<br /><br />LAST_DDL_TIME<br />-------------------<br />2008/05/28 22:11:11                                                             <br /><br />SQL&gt; -- Now flashback to the first marker or<br />SQL&gt; -- anytime after creation but before update<br />SQL&gt; flashback table emp to timestamp<br />  2  to_timestamp('2008/05/28 22:10:00','YYYY/MM/DD HH24:MI:SS');<br /><br />Flashback complete.<br /><br />SQL&gt;<br />SQL&gt; -- Verify the flashback worked<br />SQL&gt; select first_name, last_name, salary<br />  2  from emp<br />  3  where employee_id=101;<br /><br />FIRST_NAME           LAST_NAME                     SALARY<br />-------------------- ------------------------- ----------<br />Neena                Kochhar                        17000                       <br /><br />SQL&gt;<br />SQL&gt; -- Clean up<br />SQL&gt; drop table emp;<br /><br />Table dropped.<br /><br />SQL&gt;</span></pre>So, I’m still looking for a straight-forward way to identify a point-of-no-return for flashback for future reference. When I asked around the shop, the consensus seemed to be that using <a href="http://download.oracle.com/docs/cd/B19306_01/server.102/b14215/logminer.htm#SUTIL019">LogMiner</a> would be the best way to not only find the SCN of the table structure changes, but to get the SQL to “undo” the table change (if I so desired), and even to undo the effects of the <code>UPDATE</code> statement.<br /><br />Apologies for the long block of code.  And thanks to <a href="http://www.pythian.com/blogs/author/billette">Marc</a>, <a href="http://www.pythian.com/blogs/author/shamsudeen/">Riyaj</a>, <a href="http://www.pythian.com/blogs/author/alexf/">Alex F.</a>, and <a href="http://www.pythian.com/blogs/author/alex/">Alex G.</a> for their help.