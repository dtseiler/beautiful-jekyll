---
layout: post
title: Why Is My MView Log Not Purging?
date: '2014-03-16T15:50:00.000-05:00'
author: Don Seiler
tags:
- 11gR2
- materialized view logs
- materialized views
- oracle
modified_time: '2014-03-16T15:50:18.831-05:00'
blogger_id: tag:blogger.com,1999:blog-7032512792942232766.post-2995536054597544644
blogger_orig_url: http://www.seiler.us/2014/03/why-is-my-mview-log-not-purging.html
---

<span style="font-size: small;"><span style="font-family: inherit;">A few weeks ago we saw one of our tablespaces growing at a rate much higher than the others. Taking a look we saw that the biggest users of space were two materialized view logs, one being 110 Gb and the other 60 Gb. These logs were in place to facilitate the fast refresh of two materialized views, one for each log/table. These materialized views did some aggregations (sum) throughout the day on some important base table data. The fast refreshes were completing successfully many times a day, but the logs were not being purged as expected.</span></span><br /><span style="font-size: small;"><span style="font-family: inherit;"><br /></span></span><span style="font-size: small;"><span style="font-family: inherit;">In our case, there was only one mview performing a fast refresh on those base tables, so the mview logs should have been completely purged after each refresh. They certainly shouldn't be growing to over 100+ Gb. Looking at the data in the mview log, all records had a SNAPTIME$$ value of "4000/01/01 00:00:00", which is the default value for records in the mview log that </span></span><span style="font-size: small;"><span style="font-family: inherit;">have not been refreshed. Once they are refreshed, the SNAPTIME$$ value gets set to SYSDATE and can then be evaluated for purging.</span></span><br /><span style="font-size: small;"><span style="font-family: inherit;"><br /></span></span><span style="font-size: small;"><span style="font-family: inherit;">But why was this value not being updated after refresh?</span></span><br /><span style="font-size: small;"><span style="font-family: inherit;"></span></span><br /><a name='more'></a><span style="font-size: small;"><span style="font-family: inherit;">&nbsp;</span></span><br /><span style="font-size: small;"><span style="font-family: inherit;">For those of you unfamiliar with the role of materialized view logs, I'll share this primer from Tim Hall via his <a href="http://www.oracle-base.com/articles/misc/materialized-views.php#create-materialized-view-logs" target="_blank">excellent Oracle-Base article</a>:</span></span><br /><br /><blockquote class="tr_bq">Since a complete refresh involves truncating the materialized view  segment and re-populating it using the related query, it can be quite  time consuming and involve a considerable amount of network traffic when  performed against a remote table. To reduce the replication costs,  materialized view logs can be created to capture all changes to the base  table since the last refresh. This information allows a fast refresh,  which only needs to apply the changes rather than a complete refresh of  the materialized view.</blockquote><span style="font-size: small;"><span style="font-family: inherit;"><br /></span></span><span style="font-size: small;"><span style="font-family: inherit;">Digging deeper led me to MOS DocId </span></span>236233.1, which tells us that Oracle compares the MLOG$_&lt;TABLE_NAME&gt;.SNAPTIME$$ value against the SYS.SLOG$SNAPTIME:<br /><br /><blockquote class="tr_bq">Rows in the MView log are unnecessary if their refresh timestamps MLOG$<i>&lt;table_name&gt;.SNAPTIME$$ are older or equal than the oldest entry in SLOG$.SNAPTIME for this log.<br />  <br />  </i><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">MLOG$</span><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&lt;table_name&gt;.SNAPTIME$$ &lt;= MIN (SLOG$.SNAPTIME)</span></blockquote><br /><span style="font-family: inherit;"><span style="font-size: small;">Here's where we saw the real problem.</span></span><br /><span style="font-family: inherit;"><span style="font-size: small;"><br /></span></span><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><span style="font-size: small;">SQL&gt; select MOWNER,MASTER,SNAPSHOT,SNAPID,SNAPTIME,SSCN,USER#</span></span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><span style="font-size: small;">&nbsp;2  from sys.slog$</span></span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><span style="font-size: small;">&nbsp;3  where mowner='FOO' and master='BAR';</span></span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></span><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><span style="font-size: small;">&nbsp;no rows selected </span></span><br /><br /><span style="font-family: inherit;"><span style="font-size: small;">If the purge mechanism checks SLOG$.SNAPTIME then of course nothing is going to happen, as the materialized view is NOT registered in SYS.SLOG$!</span></span><br /><span style="font-family: inherit;"><span style="font-size: small;"><br /></span></span><span style="font-family: inherit;"><span style="font-size: small;">We re-created the MVIEW from scratch on our development database and had the same results, which indicates it's something systemic in Oracle so we opened an SR. After the standard back-and-forth of trying the same things over and over, Oracle Support said that this was actually expected behavior:</span></span><br /><blockquote class="tr_bq">  This mview is defined as fast refreshable with aggregates.   The mv log is defined with PRIMARY KEY INCLUDING NEW VALUES.<br />  <br />  <b>In order to support fast refresh the mv log should include ROWID as well.</b>  Please review the Restrictions on Fast Refresh on Materialized Views with   Aggregates located here:<br />     <a href="http://docs.oracle.com/cd/E11882_01/server.112/e25554/basicmv.htm#DWHSG8203" target="_blank">http://docs.oracle.com/cd/E11882_01/server.112/e25554/basicmv.htm#DWHSG8203</a></blockquote><blockquote class="tr_bq">     There are additional restrictions depending on the operations performed.   As an example, SEQUENCE should also need to be added to the mv log if direct   loads are performed on new_invoice_record.</blockquote><span style="font-family: inherit;"><span style="font-size: small;">This turned out to be the case. We recreated the mview log with the ROWID specification, then re-created the materialized view and, sure enough, the mview was registered in SYS.SLOG$ and refreshes were purging the log as expected.</span></span><br /><span style="font-family: inherit;"><span style="font-size: small;"><br /></span></span><span style="font-family: inherit;"><span style="font-size: small;">I was more than a little frustrated then that Oracle would let us create the MVIEW without any warnings or errors in the first place. The database obviously detected something wrong since it wouldn't register them in SYS.SLOG$. Their last response was that, since the MVIEW itself was refreshing successfully, no error should be reported. This fails to address the question for me, so I'm going to push back a little harder and will share what I find.</span></span><br /><br /><span style="font-family: inherit;"><span style="font-size: small;">For now, though, we need to schedule a maintenance window to recreate these materialized views and their logs and see if we can reclaim some disk space afterward (perhaps a future post!).</span></span>