---
layout: post
title: Bind Variables and Parallel Queries Do Not Mix
date: '2008-04-23T08:53:00.000-05:00'
author: Don Seiler
tags: 
modified_time: '2010-11-20T11:57:33.324-06:00'
blogger_id: tag:blogger.com,1999:blog-7032512792942232766.post-4684361500442328746
blogger_orig_url: http://www.seiler.us/2008/04/bind-variables-and-parallel-queries-do.html
---

This post was promised long ago, and I apologize for the tardiness.  Some of you may recall my whining about seemingly unexplainable instance hanging since migrating our database to 64-bit hardware in September.  Well, after some back and forth and hand-offs from one rep to another, we finally were given a possible explanation: <a href="https://metalink.oracle.com/metalink/plsql/f?p=130:14:3574037576399007154::::p14_database_id,p14_docid,p14_show_header,p14_show_help,p14_black_frame,p14_font:NOT,4367986.8,1,1,1,helvetica">Bug 4367986</a>.  The summary of the bug is "bind peeked parallel cursors do not share."  This basically means that parallel queries that use bind variables won't share cursors.  Not only does this defeat the purpose of using the bind variables, but it creates a new cursor for each parallel process.  After a while, your cursor count will go up, just as mine did:<br /><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;"><span class="Apple-style-span" style="font-size: x-small;">select sql_id, count(*)</span></span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;"><span class="Apple-style-span" style="font-size: x-small;">from v$sql_shared_cursor</span></span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;"><span class="Apple-style-span" style="font-size: x-small;">where bind_peeked_pq_mismatch='Y'</span></span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;"><span class="Apple-style-span" style="font-size: x-small;">group by sql_id;</span></span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;"><span class="Apple-style-span" style="font-size: x-small;"><br /></span></span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;"><span class="Apple-style-span" style="font-size: x-small;">SQL_ID &nbsp; &nbsp; &nbsp; &nbsp;COUNT(*)</span></span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;"><span class="Apple-style-span" style="font-size: x-small;">------------- ----------</span></span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;"><span class="Apple-style-span" style="font-size: x-small;">f3u64ru922snx        520</span></span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;"><span class="Apple-style-span" style="font-size: x-small;">ckha07wkfaf8v          5</span></span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;"><span class="Apple-style-span" style="font-size: x-small;">9g26upcqjh8kp          1</span></span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;"><span class="Apple-style-span" style="font-size: x-small;">gdnga6d26vf4g         15</span></span><br /><br />While I wasn't able to choke and hang the instance in development, I was able to drive the count up as we saw in production.<br /><br />We probably didn't see this before our x86_64 migration because on our 32-bit instance, our parallel_max_servers was only set to 16.  After migrating to the new hardware it was raised to 80 based on "the formula".  Dropping it to 0 obviously prevented the problem from coming up as well.<br /><br />The bug is reportedly fixed in 10.2.0.4, which wasn't released at the time we were finishing up the SR.  There was only a one-off patch for 10.2.0.3, meaning we had to upgrade from 10.2.0.2.  Well we did this, applied the patch, and haven't had a reoccurrence of the problem since.  That query listed above now happily returns no rows.<br /><br />Of course there was also the issue of using bind variables in queries against partitioned tables.  <a href="http://structureddata.org/">Greg Rahn</a> had this to say:<br /><blockquote>Using PQ with <span class="nfakPe">binds</span> can have other adverse effects, specifically if&nbsp;the partition key is not provided as a literal.  When the partition&nbsp;key is a bind, the resulting plan will be a KEY-KEY plan (for&nbsp;pstart/pstop) because w/o a literal value the optimizer can not tell&nbsp;if there is any partition elimination since the literal value is not&nbsp;provided at parse time.  This often times results in a "worst case"&nbsp;assumption, thus is it possible to have different plans even when the&nbsp;bind and literal statements use the same values.<br /><br />I would speculate that the overhead of parsing literals when using PQ&nbsp;is minimal compared to the side effects it is causing (due to the bug)&nbsp;and the potential of suboptimal plans.  I personally would never mix&nbsp;the two.</blockquote>